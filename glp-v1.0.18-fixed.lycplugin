{
  "metadata": {
    "id": "glp",
    "name": "GLP",
    "version": "1.0.18",
    "description": "This is the best plugin",
    "author": "Joshua",
    "route": "/glp",
    "icon": "BoltIcon",
    "permissions": [
      "devices:read",
      "devices:write",
      "measurements:read",
      "measurements:write",
      "files:read",
      "files:write"
    ],
    "tauriCommands": [
      "custom_connect_device",
      "custom_disconnect_device",
      "custom_start_sequence",
      "custom_stop_sequence",
      "custom_get_results",
      "custom_configure_sequence",
      "custom_import_data"
    ],
    "category": "Measurement Tools",
    "tags": [
      "josh"
    ],
    "requiresLicense": false,
    "minCentcomVersion": "1.0.0",
    "dependencies": [],
    "buildHistory": [
      {
        "buildName": "GLP test",
        "version": "1.0.15",
        "releaseNotes": "",
        "builtAt": "2025-08-15T04:20:58.395Z",
        "buildKey": "BLD-011"
      },
      {
        "buildName": "Output logs checking",
        "version": "1.0.14",
        "releaseNotes": "what do they say",
        "builtAt": "2025-08-13T23:02:34.627Z",
        "buildKey": "BLD-010"
      },
      {
        "buildName": "Filename match fix",
        "version": "1.0.13",
        "releaseNotes": "should register with same name",
        "builtAt": "2025-08-13T22:54:07.208Z",
        "buildKey": "BLD-009"
      },
      {
        "buildName": "PDS ID test",
        "version": "1.0.12",
        "releaseNotes": "what is the ID route",
        "builtAt": "2025-08-13T22:50:42.724Z",
        "buildKey": "BLD-008"
      },
      {
        "buildName": "/new-plugin-3 route",
        "version": "1.0.11",
        "releaseNotes": "",
        "builtAt": "2025-08-13T22:37:07.749Z",
        "buildKey": "BLD-007"
      },
      {
        "buildName": "BLD Validation + Key Fix",
        "version": "1.0.10",
        "releaseNotes": "description",
        "builtAt": "2025-08-13T22:26:04.250Z",
        "buildKey": "BLD-006"
      },
      {
        "buildName": "Build Validation Fix",
        "version": "1.0.9",
        "releaseNotes": "Does it work?",
        "builtAt": "2025-08-13T22:23:28.712Z",
        "buildKey": "BLD-meajee1k-irr8"
      },
      {
        "buildName": "Built after tested w simulator",
        "version": "1.0.8",
        "releaseNotes": "does it work?",
        "builtAt": "2025-08-13T22:10:40.430Z",
        "buildKey": "BLD-005"
      },
      {
        "buildName": "Newest Build w Logs",
        "version": "1.0.7",
        "releaseNotes": "does it work?",
        "builtAt": "2025-08-13T00:15:01.596Z",
        "buildKey": "BLD-004"
      },
      {
        "buildName": "Newest build with PDS and logs",
        "version": "1.0.6",
        "releaseNotes": "this should have build logs",
        "builtAt": "2025-08-13T00:07:59.533Z",
        "buildKey": "BLD-003"
      },
      {
        "buildName": "Latest PDS build",
        "version": "1.0.5",
        "releaseNotes": "Updated to test",
        "builtAt": "2025-08-12T23:54:09.481Z",
        "buildKey": "BLD-004"
      },
      {
        "buildName": "PDS Gui Build",
        "version": "1.0.4",
        "releaseNotes": "App built using the gui template",
        "builtAt": "2025-08-12T23:50:57.239Z",
        "buildKey": "BLD-003"
      },
      {
        "buildName": "The 3rd build release",
        "version": "1.0.3",
        "releaseNotes": "of many more",
        "builtAt": "2025-08-11T20:23:37.640Z",
        "buildKey": "BLD-002"
      },
      {
        "buildName": "Next best build",
        "version": "1.0.2",
        "releaseNotes": "of many many more",
        "builtAt": "2025-08-11T18:46:13.353Z",
        "buildKey": "BLD-001"
      },
      {
        "buildName": "Fixed Plugin ID for Centcom Compatibility",
        "version": "1.0.18",
        "releaseNotes": "Updated plugin ID to 'glp' to match Centcom expectations",
        "builtAt": "2025-08-18T17:15:00.000Z",
        "buildKey": "BLD-013"
      }
    ],
    "color": "#3bd8f7"
  },
  "frontend": {
    "main": "import { React, useState, useEffect, useCallback } from 'react';\nimport { invoke } from '@tauri-apps/api';\nimport { createCentcomAPI, CentcomUtils } from '../lib/centcomAPI';\n\ninterface ComponentProps {\n  pluginId: string;\n  onDataUpdate?: (data: any) => void;\n  onError?: (error: string) => void;\n}\n\ninterface ComponentState {\n  error: string | null;\n  loading: boolean;\n}\n\nconst PluginGUI: React.FC<ComponentProps> = ({ pluginId, onDataUpdate, onError }) => {\n\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [centcomAPI, setCentcomAPI] = useState(null);\n\n  // Initialize Centcom API\n  useEffect(() => {\n    const api = createCentcomAPI(pluginId);\n    setCentcomAPI(api);\n    \n    return () => {\n      api.destroy();\n    };\n  }, [pluginId]);\n\n\n\n  return (\n    <div className=\"plugin-gui-container\">\n      <div className=\"flex-layout\">\n        <div className=\"unknown-component\" id=\"app_title\">\n          <span>Component: textDisplay</span>\n        </div>\n        <div className=\"unknown-component\" id=\"app_description\">\n          <span>Component: textDisplay</span>\n        </div>\n        <div className=\"unknown-component\" id=\"main_tabs\">\n          <span>Component: tabContainer</span>\n        </div>\n        <div className=\"unknown-component\" id=\"connection_status\">\n          <span>Component: statusIndicator</span>\n        </div>\n        <div className=\"unknown-component\" id=\"recent_activity\">\n          <span>Component: activityLog</span>\n        </div>\n        <div className=\"unknown-component\" id=\"general_settings\">\n          <span>Component: settingsGroup</span>\n        </div>\n        <div className=\"unknown-component\" id=\"auto_connect\">\n          <span>Component: toggle</span>\n        </div>\n        <div className=\"input-field\">\n          {\"Device Under Test\" && <label>Device Under Test</label>}\n          <input\n            type=\"text\"\n            placeholder=\"Enter text...\"\n            required={false}\n            onChange={(e) => {\n              // handleInputChange implementation\n            }}\n          />\n        </div>\n      </div>\n    </div>\n  );\n\n};\n\nconst styles = `\n.plugin-gui-container {\n  font-family: system-ui, sans-serif;\n  padding: 16px;\n  background: #ffffff;\n  color: #1f2937;\n}\n\n.device-connector, .sensor-monitor, .data-logger, .sequence-controller, .realtime-chart {\n  border: 1px solid #e5e7eb;\n  border-radius: 8px;\n  padding: 16px;\n  margin-bottom: 16px;\n  background: #f9fafb;\n}\n\n.status-indicator {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n  display: inline-block;\n}\n\n.status-indicator.connected, .status-indicator.logging, .status-indicator.running {\n  background-color: #10b981;\n  animation: pulse 2s infinite;\n}\n\n.status-indicator.disconnected, .status-indicator.idle {\n  background-color: #6b7280;\n}\n\n@keyframes pulse {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.5; }\n}\n\n.btn {\n  padding: 8px 16px;\n  border-radius: 4px;\n  border: none;\n  cursor: pointer;\n  font-weight: 500;\n  transition: all 0.2s;\n}\n\n.btn.primary {\n  background-color: #3b82f6;\n  color: white;\n}\n\n.btn.primary:hover {\n  background-color: #2563eb;\n}\n\n.btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.chart-placeholder {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 200px;\n  border: 2px dashed #d1d5db;\n  border-radius: 4px;\n  background: #f9fafb;\n}\n\n.chart-icon {\n  width: 48px;\n  height: 48px;\n  margin-right: 8px;\n  color: #6b7280;\n}\n\n\n@media (max-width: 768px) {\n  .plugin-gui-container {\n    padding: 8px;\n  }\n  \n  .device-connector, .sensor-monitor, .data-logger, .sequence-controller, .realtime-chart {\n    margin-bottom: 8px;\n    padding: 12px;\n  }\n}\n\n`;\n\n// Inject styles\nconst styleSheet = document.createElement('style');\nstyleSheet.type = 'text/css';\nstyleSheet.innerText = styles;\ndocument.head.appendChild(styleSheet);\n\nexport default PluginGUI;",
    "styles": "/* Any custom CSS styling for the plugin */\n.custom-plugin-container {\n  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n}\n\n.custom-chart-container {\n  height: 300px;\n  width: 100%;\n  position: relative;\n}\n\n.custom-loading-indicator {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}"
  },
  "backend": {
    "main": "use std::collections::HashMap;\nuse std::sync::Mutex;\nuse tauri::{command, plugin::TauriPlugin, Runtime, State};\nuse serde::{Serialize, Deserialize};\nuse chrono::prelude::*;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct DeviceInfo {\n    name: String,\n    model: String,\n    serial: String,\n    connected: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct MeasurementData {\n    timestamp: String,\n    values: Vec<f64>,\n    labels: Vec<String>,\n    metadata: HashMap<String, String>,\n}\n\n#[derive(Debug, Default)]\nstruct PluginState {\n    connected_device: Mutex<Option<DeviceInfo>>,\n    is_running: Mutex<bool>,\n    license: Mutex<Option<License>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct License {\n    key: String,\n    valid_until: Option<String>,\n    features: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CommandResponse<T> {\n    success: bool,\n    error: Option<String>,\n    data: Option<T>,\n}\n\nimpl<T> CommandResponse<T> {\n    fn success(data: T) -> Self {\n        CommandResponse {\n            success: true,\n            error: None,\n            data: Some(data),\n        }\n    }\n\n    fn error(message: &str) -> Self {\n        CommandResponse {\n            success: false,\n            error: Some(message.to_string()),\n            data: None,\n        }\n    }\n}\n\n#[command]\nasync fn custom_connect_device(\n    state: State<'_, PluginState>\n) -> Result<CommandResponse<DeviceInfo>, String> {\n    // In a real plugin, you would implement actual device connection logic\n    // For this skeleton, we're just mocking the connection\n    \n    let device = DeviceInfo {\n        name: \"Demo Device\".to_string(),\n        model: \"Model X-1000\".to_string(),\n        serial: \"SN12345678\".to_string(),\n        connected: true,\n    };\n    \n    // Update the plugin state\n    *state.connected_device.lock().unwrap() = Some(device.clone());\n    \n    Ok(CommandResponse::success(device))\n}\n\n#[command]\nasync fn custom_disconnect_device(\n    state: State<'_, PluginState>\n) -> Result<CommandResponse<bool>, String> {\n    // In a real plugin, you would implement actual device disconnection logic\n    // For this skeleton, we're just mocking the disconnection\n    \n    // Update the plugin state\n    *state.connected_device.lock().unwrap() = None;\n    *state.is_running.lock().unwrap() = false;\n    \n    Ok(CommandResponse::success(true))\n}\n\n#[command]\nasync fn custom_start_sequence(\n    state: State<'_, PluginState>\n) -> Result<CommandResponse<bool>, String> {\n    // Check if a device is connected\n    if state.connected_device.lock().unwrap().is_none() {\n        return Ok(CommandResponse::error(\"No device connected\"));\n    }\n    \n    // Check if already running\n    if *state.is_running.lock().unwrap() {\n        return Ok(CommandResponse::error(\"Sequence already running\"));\n    }\n    \n    // In a real plugin, you would start the actual measurement sequence\n    // For this skeleton, we're just updating the state\n    *state.is_running.lock().unwrap() = true;\n    \n    Ok(CommandResponse::success(true))\n}\n\n#[command]\nasync fn custom_stop_sequence(\n    state: State<'_, PluginState>\n) -> Result<CommandResponse<bool>, String> {\n    // In a real plugin, you would stop the actual measurement sequence\n    // For this skeleton, we're just updating the state\n    *state.is_running.lock().unwrap() = false;\n    \n    Ok(CommandResponse::success(true))\n}\n\n#[command]\nasync fn custom_get_results(\n    state: State<'_, PluginState>\n) -> Result<CommandResponse<MeasurementData>, String> {\n    // In a real plugin, you would retrieve actual measurement data\n    // For this skeleton, we're just generating mock data\n    \n    let now = Utc::now();\n    let timestamp = now.to_rfc3339();\n    \n    let data = MeasurementData {\n        timestamp,\n        values: vec![0.1, 0.2, 0.3, 0.4, 0.5],\n        labels: vec![\"Point 1\".to_string(), \"Point 2\".to_string(), \"Point 3\".to_string(), \n                    \"Point 4\".to_string(), \"Point 5\".to_string()],\n        metadata: HashMap::from([\n            (\"unit\".to_string(), \"volts\".to_string()),\n            (\"sampling_rate\".to_string(), \"1000\".to_string()),\n        ]),\n    };\n    \n    Ok(CommandResponse::success(data))\n}\n\n#[command]\nasync fn custom_import_data(\n    file_path: String,\n) -> Result<CommandResponse<MeasurementData>, String> {\n    // In a real plugin, you would read and parse the actual file\n    // For this skeleton, we're just generating mock data based on the file path\n    \n    let now = Utc::now();\n    let timestamp = now.to_rfc3339();\n    \n    let data = MeasurementData {\n        timestamp,\n        values: vec![1.1, 2.2, 3.3, 4.4, 5.5],\n        labels: vec![\"Imported 1\".to_string(), \"Imported 2\".to_string(), \n                    \"Imported 3\".to_string(), \"Imported 4\".to_string(), \n                    \"Imported 5\".to_string()],\n        metadata: HashMap::from([\n            (\"file\".to_string(), file_path),\n            (\"unit\".to_string(), \"amps\".to_string()),\n        ]),\n    };\n    \n    Ok(CommandResponse::success(data))\n}\n\n#[command]\nasync fn custom_configure_sequence(\n    config: HashMap<String, String>,\n) -> Result<CommandResponse<bool>, String> {\n    // In a real plugin, you would validate and store the configuration\n    // For this skeleton, we're just acknowledging receipt\n    \n    Ok(CommandResponse::success(true))\n}\n\n#[command]\nasync fn check_plugin_license(\n    plugin_id: String,\n    state: State<'_, PluginState>,\n) -> Result<CommandResponse<bool>, String> {\n    // In a real plugin, you would validate the license against a secure source\n    // For this skeleton, we're just returning a mock response\n    \n    // Mock license validation\n    let is_valid = plugin_id == \"custom-plugin-skeleton\";\n    \n    if is_valid {\n        // Store license information in state\n        let license = License {\n            key: \"DEMO-LICENSE-KEY\".to_string(),\n            valid_until: None, // Perpetual license\n            features: vec![\"basic\".to_string(), \"advanced\".to_string()],\n        };\n        \n        *state.license.lock().unwrap() = Some(license);\n    } else {\n        *state.license.lock().unwrap() = None;\n    }\n    \n    Ok(CommandResponse::success(is_valid))\n}\n\n// Initialize plugin\npub fn init<R: Runtime>() -> TauriPlugin<R> {\n    let state = PluginState::default();\n    \n    tauri::plugin::Builder::new(\"custom-plugin-skeleton\")\n        .invoke_handler(tauri::generate_handler![\n            custom_connect_device,\n            custom_disconnect_device,\n            custom_start_sequence,\n            custom_stop_sequence,\n            custom_get_results,\n            custom_import_data,\n            custom_configure_sequence,\n            check_plugin_license\n        ])\n        .setup(|app| {\n            app.manage(state);\n            Ok(())\n        })\n        .build()\n}",
    "sequencer": {
      "steps": [
        {
          "id": "connect_device",
          "name": "Connect Device",
          "description": "Connect to measurement device",
          "command": "custom_connect_device",
          "parameters": [],
          "outputs": [
            "device_info"
          ]
        },
        {
          "id": "configure_measurement",
          "name": "Configure Measurement",
          "description": "Configure measurement parameters",
          "command": "custom_configure_sequence",
          "parameters": [
            {
              "name": "sampling_rate",
              "type": "number",
              "description": "Sampling rate in Hz",
              "default": 1000,
              "min": 100,
              "max": 10000
            },
            {
              "name": "duration",
              "type": "number",
              "description": "Measurement duration in seconds",
              "default": 5,
              "min": 1,
              "max": 60
            }
          ],
          "outputs": [
            "config_success"
          ]
        },
        {
          "id": "start_measurement",
          "name": "Start Measurement",
          "description": "Begin data acquisition sequence",
          "command": "custom_start_sequence",
          "parameters": [],
          "outputs": [
            "sequence_started"
          ]
        },
        {
          "id": "get_results",
          "name": "Get Results",
          "description": "Retrieve measurement results",
          "command": "custom_get_results",
          "parameters": [],
          "outputs": [
            "measurement_data"
          ]
        },
        {
          "id": "disconnect_device",
          "name": "Disconnect Device",
          "description": "Disconnect from measurement device",
          "command": "custom_disconnect_device",
          "parameters": [],
          "outputs": [
            "disconnected"
          ]
        },
        {
          "id": "save_to_project",
          "name": "Save To Project",
          "description": "Save measurement results to project",
          "command": "save_to_project",
          "parameters": [
            {
              "name": "project_name",
              "type": "string",
              "description": "Project name",
              "default": ""
            },
            {
              "name": "tags",
              "type": "array",
              "description": "Tags for categorization",
              "default": []
            }
          ],
          "outputs": [
            "save_result"
          ]
        }
      ]
    }
  },
  "license": {
    "validation": {
      "type": "token",
      "mechanism": "rsa",
      "public_key": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzw8y2JNS+IOiRKnMaNKR\nuXxK3AP5dcAdgJUZaXxIK5fi1VJQRy4QjbFUnM4AJVeGEGsHgriWnP6jOKX/EqJu\nMG/QDde6xble9N8D9mpIJoIOZf//u1MJiGQw+Z5lzK8lJLnyn5qvvYsaT6S9Kehw\n7kH0CbmOSDasqFV5F3L9V5K0UIzeGT/KfE6EYzUzT/GUYpHvUbbBN+PtBeb4zGSb\nqEiFgZ1qq9jQzA7Z3qO6flMp8bQ9Utr7pu/pjKKmmJzNzHwH7YlT0Pw06RTZcZ0b\nofVQMzAIibX6l1kXpEzRPFLECrow2QVj/zJoWNOfKIcEKK5v4VxC8lJPQjmOUJFt\nowIDAQAB\n-----END PUBLIC KEY-----"
    },
    "features": [
      {
        "id": "basic",
        "name": "Basic Features",
        "description": "Core plugin functionality including data acquisition and visualization"
      },
      {
        "id": "advanced",
        "name": "Advanced Features",
        "description": "Advanced analysis tools and export capabilities"
      },
      {
        "id": "automation",
        "name": "Automation",
        "description": "Sequencer automation and batch processing"
      }
    ]
  },
  "licensing": {
    "enabled": false,
    "requiresLicense": false,
    "allowOffline": false,
    "maxOfflineDays": 365,
    "remoteValidation": {
      "enabled": false,
      "endpoint": "",
      "publicKey": "",
      "checkInterval": 24
    },
    "tiers": [
      {
        "id": "tier_1754944688519",
        "name": "Basic",
        "price": 0,
        "currency": "USD",
        "duration": "perpetual",
        "durationValue": 0,
        "maxUsers": 1,
        "features": [],
        "description": "",
        "trialDays": 0,
        "stackable": false
      }
    ],
    "cryptography": {
      "algorithm": "RSA-2048",
      "keySize": 2048,
      "hashAlgorithm": "SHA-256"
    },
    "features": [],
    "licenseServer": {
      "url": "",
      "apiKey": "",
      "allowSelfSigned": false
    }
  },
  "gui": {
    "components": [
      {
        "id": "app_title",
        "type": "textDisplay",
        "props": {
          "text": "GLP",
          "fontSize": "24px",
          "fontWeight": "bold",
          "textAlign": "Left",
          "color": "#1f2937"
        },
        "position": {
          "x": 20,
          "y": 20
        },
        "size": {
          "width": 760,
          "height": 40
        }
      },
      {
        "id": "app_description",
        "type": "textDisplay",
        "props": {
          "text": "This application provides essential functionality for device control and monitoring. Configure settings and manage your devices through the tabs below.",
          "fontSize": "14px",
          "fontWeight": "normal",
          "textAlign": "left",
          "color": "#6b7280"
        },
        "position": {
          "x": 20,
          "y": 70
        },
        "size": {
          "width": 760,
          "height": 50
        }
      },
      {
        "id": "main_tabs",
        "type": "tabContainer",
        "props": {
          "tabs": [
            "General",
            "Controls",
            "Settings"
          ],
          "activeTab": 0,
          "tabStyle": "horizontal",
          "showBorder": true
        },
        "position": {
          "x": 20,
          "y": 140
        },
        "size": {
          "width": 760,
          "height": 450
        }
      },
      {
        "id": "connection_status",
        "type": "statusIndicator",
        "props": {
          "label": "Connection Status",
          "status": "connected",
          "showStatusText": true,
          "colors": {
            "connected": "#10b981",
            "disconnected": "#ef4444",
            "connecting": "#f59e0b"
          }
        },
        "position": {
          "x": 410,
          "y": 200
        },
        "size": {
          "width": 320,
          "height": 60
        }
      },
      {
        "id": "recent_activity",
        "type": "activityLog",
        "props": {
          "title": "Recent Activity",
          "maxEntries": 5,
          "showTimestamp": true,
          "autoRefresh": true
        },
        "position": {
          "x": 42,
          "y": 414
        },
        "size": {
          "width": 350,
          "height": 180
        }
      },
      {
        "id": "general_settings",
        "type": "settingsGroup",
        "props": {
          "title": "General Settings",
          "collapsible": false
        },
        "position": {
          "x": 40,
          "y": 201
        },
        "size": {
          "width": 340,
          "height": 200
        }
      },
      {
        "id": "auto_connect",
        "type": "toggle",
        "props": {
          "label": "Auto Connect on Startup",
          "checked": false,
          "onChange": "handleAutoConnectChange"
        },
        "position": {
          "x": 60,
          "y": 320
        },
        "size": {
          "width": 250,
          "height": 40
        }
      },
      {
        "id": "component_1755111708032_babogsuln",
        "type": "input",
        "props": {
          "label": "Device Under Test",
          "placeholder": "Enter text...",
          "type": "text",
          "required": false,
          "value": "",
          "onChange": "handleInputChange"
        },
        "position": {
          "x": 60,
          "y": 226
        },
        "size": {
          "width": 200,
          "height": 50
        }
      }
    ],
    "settings": {
      "title": "Basic Application",
      "theme": "light",
      "layout": "tabbed",
      "responsive": true,
      "tabNavigation": true
    },
    "version": "1.0",
    "lastModified": "2025-08-18T16:43:37.126Z"
  }
}